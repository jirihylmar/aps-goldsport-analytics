<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Analytics - Period Comparison</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        .chart-tooltip {
            position: absolute;
            padding: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: none;
            font-size: 12px;
            opacity: 0;
            z-index: 100;
        }
        .chart-tooltip.visible { opacity: 1; }
        .chart-container {
            height: 180px !important;
        }
        .chart-section {
            margin-bottom: 1rem !important;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto p-4 max-w-full">
        <div class="flex justify-between items-center mb-6">
            <div>
                <h1 id="mainTitle" class="text-2xl font-bold">Analytics by Language | Cumulative | Latest day processed: Loading...</h1>
                <div class="flex gap-6 mt-2">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3" style="background-color: #4f46e5"></div>
                        <span>Main Page</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3" style="background-color: #e11d48"></div>
                        <span>Order Page</span>
                    </div>
                </div>
            </div>
            <div class="flex gap-4">
                <select id="metricSelector" class="p-2 border rounded">
                    <option value="New users">New Users</option>
                    <option value="Active users">Active Users</option>
                    <option value="Sessions">Sessions</option>
                    <option value="Average engagement time per session">Avg. Engagement Time</option>
                </select>
                <select id="timeSelector" class="p-2 border rounded">
                    <option value="daily">Daily</option>
                    <option value="weekly">Weekly</option>
                </select>
            </div>
        </div>
        <div id="chartsContainer" class="space-y-4"></div>
    </div>

    <script>
        const DATA_CONFIG = {
            dataPath: 'goldsport__ga_classicskischool_daily_metrix___gsp_dataset___auto_full/method=auto_full/source=goldsport/goldsport__ga_classicskischool_daily_metrix.tsv'
        };

        const LANG_PATHS = {
            en: {
                main: '/en',
                order: '/en/objednavka',
                label: 'English'
            },
            de: {
                main: '/de',
                order: '/de/objednavka',
                label: 'German'
            },
            pl: {
                main: '/pl',
                order: '/pl/objednavka',
                label: 'Polish'
            },
            cs: {
                main: '/',
                order: '/objednavka',
                label: 'Czech'
            }
        };

        const COLORS = {
            main: '#4f46e5',
            order: '#e11d48'
        };

        const TIME_PERIODS = {
            period1: {
                start: new Date('2023-12-01'),
                end: new Date('2024-03-31'),
                label: '2023 Dec - 2024 Mar'
            },
            period2: {
                start: new Date('2024-12-01'),
                end: new Date('2025-03-31'),
                label: '2024 Dec - 2025 Mar'
            }
        };

        function createChart(data, lang, containerId, period, maxValues) {
            const container = document.getElementById(containerId);
            d3.select(`#${containerId}`).selectAll('*').remove();

            const margin = {top: 20, right: 60, bottom: 30, left: 60};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            svg.append('text')
                .attr('x', width / 2)
                .attr('y', -5)
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .text(period.label);

            const x = d3.scaleTime()
                .domain([period.start, period.end])
                .range([0, width]);

            const y1 = d3.scaleLinear()
                .domain([0, maxValues.main])
                .nice()
                .range([height, 0]);

            const y2 = d3.scaleLinear()
                .domain([0, maxValues.order])
                .nice()
                .range([height, 0]);

            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .tickFormat(d3.timeFormat('%Y %b'))
                    .ticks(4));

            svg.append('g')
                .call(d3.axisLeft(y1).tickFormat(d3.format('d')))
                .append('text')
                .attr('fill', COLORS.main)
                .attr('text-anchor', 'start')
                .attr('x', 10)
                .attr('y', -10)
                .text('Main Page');

            svg.append('g')
                .attr('transform', `translate(${width},0)`)
                .call(d3.axisRight(y2).tickFormat(d3.format('d')))
                .append('text')
                .attr('fill', COLORS.order)
                .attr('text-anchor', 'end')
                .attr('x', -10)
                .attr('y', -10)
                .text('Order Page');

            const mainLine = d3.line()
                .x(d => x(d.date))
                .y(d => y1(d.mainValue))
                .defined(d => !isNaN(d.mainValue));

            const orderLine = d3.line()
                .x(d => x(d.date))
                .y(d => y2(d.orderValue))
                .defined(d => !isNaN(d.orderValue));

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', COLORS.main)
                .attr('stroke-width', 2)
                .attr('d', mainLine);

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', COLORS.order)
                .attr('stroke-width', 2)
                .attr('d', orderLine);

            svg.selectAll('dot-main')
                .data(data)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.date))
                .attr('cy', d => y1(d.mainValue))
                .attr('r', 3)
                .attr('fill', COLORS.main)
                .attr('stroke', 'white')
                .attr('stroke-width', 1);

            svg.selectAll('dot-order')
                .data(data)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.date))
                .attr('cy', d => y2(d.orderValue))
                .attr('r', 3)
                .attr('fill', COLORS.order)
                .attr('stroke', 'white')
                .attr('stroke-width', 1);

            if (containerId.includes('period1')) {
                const currentDate = new Date();
                const startOfYear = new Date(currentDate.getFullYear(), 0, 1);
                const currentWeekNumber = Math.ceil((currentDate - startOfYear) / (7 * 24 * 60 * 60 * 1000));
                
                const weekStart = new Date(period.start.getFullYear(), 0, 1);
                weekStart.setDate(weekStart.getDate() + (currentWeekNumber - 1) * 7);
                
                if (weekStart >= period.start && weekStart <= period.end) {
                    svg.append('line')
                        .attr('x1', x(weekStart))
                        .attr('x2', x(weekStart))
                        .attr('y1', 0)
                        .attr('y2', height)
                        .attr('stroke', '#000')
                        .attr('stroke-width', 1)
                        .attr('stroke-dasharray', '4,4');

                    svg.append('text')
                        .attr('x', x(weekStart) + 5)
                        .attr('y', 20)
                        .attr('text-anchor', 'start')
                        .style('font-size', '12px')
                        .text(`Current Week ${currentWeekNumber}`);
                }
            }

            const tooltip = d3.select(`#${containerId}`)
                .append('div')
                .attr('class', 'chart-tooltip');

            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', () => tooltip.classed('visible', true))
                .on('mouseout', () => tooltip.classed('visible', false))
                .on('mousemove', (event) => {
                    const [x0] = d3.pointer(event);
                    const bisectDate = d3.bisector(d => d.date).left;
                    const x1 = x.invert(x0);
                    const i = bisectDate(data, x1, 1);
                    if (i > 0) {
                        const d0 = data[i - 1];
                        const d1 = data[i] || d0;
                        const d = x1 - d0.date > d1.date - x1 ? d1 : d0;

                        const weekNum = Math.ceil((d.date - new Date(d.date.getFullYear(), 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                        const dayOfWeek = d.date.getDay();
                        const isWeekStart = dayOfWeek === 0;
                        const isWeekEnd = dayOfWeek === 6;
                        const weekLabel = isWeekStart ? 'Week Start' : isWeekEnd ? 'Week End' : '';
                        
                        tooltip.html(`
                            <div class="font-bold">
                                ${d.date.toLocaleDateString()} (Week ${weekNum})
                                ${weekLabel ? `<span class="text-gray-600"> - ${weekLabel}</span>` : ''}
                            </div>
                            <div style="color: ${COLORS.main}">Main Page: ${d.mainValue.toLocaleString()}</div>
                            <div style="color: ${COLORS.order}">Order Page: ${d.orderValue.toLocaleString()}</div>
                        `)
                            .style('left', `${event.pageX + 10}px`)
                            .style('top', `${event.pageY - 10}px`);
                    }
                });
        }

        async function loadData() {
            try {
                console.log('Attempting to load data from:', DATA_CONFIG.dataPath);
                const response = await fetch(DATA_CONFIG.dataPath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                
                const parsed = Papa.parse(text, {
                    header: true,
                    skipEmptyLines: true,
                    delimiter: '\t',
                    dynamicTyping: true
                });

                const latestDate = _.maxBy(parsed.data, row => new Date(row.date))?.date;
                document.getElementById('mainTitle').textContent = 
                    `Analytics by Language | ${document.getElementById('metricSelector').value} | Latest day processed: ${latestDate}`;

                return parsed.data;
            } catch (error) {
                console.error('Error loading data:', error);
                return [];
            }
        }

        function processData(data, selectedLang, timeframe, period, selectedMetric) {
            const paths = LANG_PATHS[selectedLang];
            
            // Filter data for the selected time period and metric
            const periodData = data.filter(row => {
                const rowDate = new Date(row.date);
                return rowDate >= period.start && 
                       rowDate <= period.end && 
                       row.type === selectedMetric;
            });

            const groupData = timeframe === 'weekly' 
                ? _.groupBy(periodData, row => {
                    const date = new Date(row.date);
                    const weekNum = Math.ceil((date - new Date(date.getFullYear(), 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                    return `${date.getFullYear()}-${weekNum}`;
                })
                : _.groupBy(periodData, 'date');

            let mainCumulative = 0;
            let orderCumulative = 0;

            return _(groupData)
                .map((rows, dateKey) => {
                    const mainRows = rows.filter(row => row.code === paths.main);
                    const orderRows = rows.filter(row => row.code === paths.order);

                    const mainValue = _.sumBy(mainRows, 'value') || 0;
                    const orderValue = _.sumBy(orderRows, 'value') || 0;

                    if (selectedMetric !== 'Average engagement time per session') {
                        mainCumulative += mainValue;
                        orderCumulative += orderValue;
                    }

                    return {
                        date: new Date(rows[0].date),
                        mainValue: selectedMetric !== 'Average engagement time per session' ? mainCumulative : mainValue,
                        orderValue: selectedMetric !== 'Average engagement time per session' ? orderCumulative : orderValue
                    };
                })
                .sortBy('date')
                .value();
        }

        function findMaxValues(data1, data2) {
            const maxMain = Math.max(
                _.maxBy(data1, 'mainValue')?.mainValue || 0,
                _.maxBy(data2, 'mainValue')?.mainValue || 0
            );
            const maxOrder = Math.max(
                _.maxBy(data1, 'orderValue')?.orderValue || 0,
                _.maxBy(data2, 'orderValue')?.orderValue || 0
            );
            return { main: maxMain, order: maxOrder };
        }

        function createLanguageSection(lang) {
            const section = document.createElement('div');
            section.className = 'bg-white rounded-lg shadow p-4 chart-section';
            
            const title = document.createElement('h2');
            title.className = 'text-lg font-bold mb-2';
            title.textContent = LANG_PATHS[lang].label;
            section.appendChild(title);
            
            const chartsWrapper = document.createElement('div');
            chartsWrapper.className = 'flex gap-4';
            
            const chartDiv1 = document.createElement('div');
            chartDiv1.className = 'chart-container flex-1';
            chartDiv1.id = `chart-${lang}-period1`;
            
            const chartDiv2 = document.createElement('div');
            chartDiv2.className = 'chart-container flex-1';
            chartDiv2.id = `chart-${lang}-period2`;
            
            chartsWrapper.appendChild(chartDiv1);
            chartsWrapper.appendChild(chartDiv2);
            section.appendChild(chartsWrapper);
            
            return section;
        }

        async function updateDashboard(data) {
            if (!data || !data.length) {
                console.error('No data available for dashboard update');
                return;
            }

            const timeframe = document.getElementById('timeSelector').value;
            const selectedMetric = document.getElementById('metricSelector').value;
            const container = document.getElementById('chartsContainer');
            container.innerHTML = '';

            // Update title with selected metric
            document.getElementById('mainTitle').textContent = 
                `Analytics by Language | ${selectedMetric} | ${selectedMetric !== 'Average engagement time per session' ? 'Cumulative | ' : ''}Latest day processed: ${_.maxBy(data, row => new Date(row.date))?.date}`;

            Object.keys(LANG_PATHS).forEach(lang => {
                const section = createLanguageSection(lang);
                container.appendChild(section);

                // Process data for both periods
                const period1Data = processData(data, lang, timeframe, TIME_PERIODS.period1, selectedMetric);
                const period2Data = processData(data, lang, timeframe, TIME_PERIODS.period2, selectedMetric);

                // Find max values across both periods for consistent scaling
                const maxValues = findMaxValues(period1Data, period2Data);

                // Create charts for both periods with consistent scaling
                createChart(period1Data, lang, `chart-${lang}-period1`, TIME_PERIODS.period1, maxValues);
                createChart(period2Data, lang, `chart-${lang}-period2`, TIME_PERIODS.period2, maxValues);
            });
        }

        async function initialize() {
            try {
                const data = await loadData();
                if (!data || !data.length) {
                    console.error('No data loaded');
                    document.getElementById('mainTitle').textContent = 'Error: No data available';
                    return;
                }

                const timeSelector = document.getElementById('timeSelector');
                const metricSelector = document.getElementById('metricSelector');
                
                timeSelector.addEventListener('change', () => updateDashboard(data));
                metricSelector.addEventListener('change', () => updateDashboard(data));
                
                await updateDashboard(data);
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                document.getElementById('mainTitle').textContent = 'Error: Failed to load data';
            }
        }

        initialize();
        window.addEventListener('resize', _.debounce(() => {
            loadData().then(data => updateDashboard(data));
        }, 250));
    </script>
</body>
</html>