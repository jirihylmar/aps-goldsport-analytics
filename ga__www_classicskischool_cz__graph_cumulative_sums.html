<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combined Analytics - Period Comparison</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        .chart-tooltip {
            position: absolute;
            padding: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: none;
            font-size: 12px;
            opacity: 0;
            z-index: 100;
        }
        .chart-tooltip.visible { opacity: 1; }
        .chart-container {
            height: 400px !important;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto p-4 max-w-full">
        <div class="flex justify-between items-center mb-6">
            <div>
                <h1 id="mainTitle" class="text-2xl font-bold">Analytics Comparison</h1>
                <div class="flex gap-6 mt-2">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3" style="background-color: #f97316"></div>
                        <span>2023 Dec to 2024 Mar real values</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 border border-orange-500" style="background-color: #f97316"></div>
                        <span>2023 Dec to 2024 Mar real values + 20% weather conditions buffer</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3" style="background-color: #22c55e"></div>
                        <span>2024 Dec to 2025 Mar real values</span>
                    </div>
                </div>
            </div>
            <div class="flex gap-4">
                <select id="metricSelector" class="p-2 border rounded">
                    <option value="New users">New Users</option>
                    <option value="Active users">Active Users</option>
                    <option value="Sessions">Sessions</option>
                    <option value="Average engagement time per session">Avg. Engagement Time</option>
                </select>
                <select id="timeSelector" class="p-2 border rounded">
                    <option value="daily">Daily</option>
                    <option value="weekly">Weekly</option>
                </select>
            </div>
        </div>
        <div class="grid grid-cols-2 gap-4">
            <div class="bg-white rounded-lg shadow p-4">
                <h2 class="text-lg font-bold mb-2">Main Page</h2>
                <div id="chart-main" class="chart-container"></div>
            </div>
            <div class="bg-white rounded-lg shadow p-4">
                <h2 class="text-lg font-bold mb-2">Order Page</h2>
                <div id="chart-order" class="chart-container"></div>
            </div>
        </div>
    </div>

    <script>
        const LANG_PATHS = {
            en: {
                main: '/en',
                order: '/en/objednavka'
            },
            de: {
                main: '/de',
                order: '/de/objednavka'
            },
            pl: {
                main: '/pl',
                order: '/pl/objednavka'
            },
            cs: {
                main: '/',
                order: '/objednavka'
            }
        };

        const COLORS = {
            period1: '#f97316',
            period2: '#22c55e',
            buffer: '#f97316'
        };

        const TIME_PERIODS = {
            period1: {
                start: new Date('2023-12-01'),
                end: new Date('2024-03-31'),
                label: '2023 Dec - 2024 Mar'
            },
            period2: {
                start: new Date('2024-12-01'),
                end: new Date('2025-03-31'),
                label: '2024 Dec - 2025 Mar'
            }
        };

        function normalizePeriod2Date(date) {
            return new Date(date.getFullYear() - 1, date.getMonth(), date.getDate());
        }

        function createChart(data, containerId, title) {
            const container = document.getElementById(containerId);
            d3.select(`#${containerId}`).selectAll('*').remove();

            const margin = {top: 20, right: 60, bottom: 30, left: 60};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const bufferData = data.period1.map(d => ({
                ...d,
                value: d.value * 1.2
            }));

            const x = d3.scaleTime()
                .domain([TIME_PERIODS.period1.start, TIME_PERIODS.period1.end])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max([...data.period1, ...data.period2, ...bufferData], d => d.value)])
                .nice()
                .range([height, 0]);

            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .tickFormat(d3.timeFormat('%b'))
                    .ticks(6));

            svg.append('g')
                .call(d3.axisLeft(y).tickFormat(d3.format(',.0f')));

            const line = d3.line()
                .x(d => x(d.normalizedDate))
                .y(d => y(d.value))
                .defined(d => !isNaN(d.value));

            svg.append('path')
                .datum(data.period1)
                .attr('fill', 'none')
                .attr('stroke', COLORS.period1)
                .attr('stroke-width', 2)
                .attr('d', line);

            svg.append('path')
                .datum(bufferData)
                .attr('fill', 'none')
                .attr('stroke', COLORS.buffer)
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '4,4')
                .attr('d', line);

            svg.append('path')
                .datum(data.period2)
                .attr('fill', 'none')
                .attr('stroke', COLORS.period2)
                .attr('stroke-width', 2)
                .attr('d', line);

            svg.selectAll('dot-period1')
                .data(data.period1)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.normalizedDate))
                .attr('cy', d => y(d.value))
                .attr('r', 3)
                .attr('fill', COLORS.period1)
                .attr('stroke', 'white')
                .attr('stroke-width', 1);

            svg.selectAll('dot-period2')
                .data(data.period2)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.normalizedDate))
                .attr('cy', d => y(d.value))
                .attr('r', 3)
                .attr('fill', COLORS.period2)
                .attr('stroke', 'white')
                .attr('stroke-width', 1);

            const tooltip = d3.select(`#${containerId}`)
                .append('div')
                .attr('class', 'chart-tooltip');

            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const startOfYear = new Date(currentYear, 0, 1);
            const currentWeekNumber = Math.ceil((currentDate - startOfYear) / (7 * 24 * 60 * 60 * 1000));
            
            const weekStart = new Date(TIME_PERIODS.period1.start.getFullYear(), 0, 1);
            weekStart.setDate(weekStart.getDate() + (currentWeekNumber - 1) * 7);
            
            if (weekStart >= TIME_PERIODS.period1.start && weekStart <= TIME_PERIODS.period1.end) {
                svg.append('line')
                    .attr('x1', x(weekStart))
                    .attr('x2', x(weekStart))
                    .attr('y1', 0)
                    .attr('y2', height)
                    .attr('stroke', '#000')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '4,4');

                svg.append('text')
                    .attr('x', x(weekStart) + 5)
                    .attr('y', 20)
                    .attr('text-anchor', 'start')
                    .style('font-size', '12px')
                    .text(`Current Week ${currentWeekNumber}`);
            }

            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', () => tooltip.classed('visible', true))
                .on('mouseout', () => tooltip.classed('visible', false))
                .on('mousemove', (event) => {
                    const [x0] = d3.pointer(event);
                    const x1 = x.invert(x0);
                    
                    const bisectDate = d3.bisector(d => d.normalizedDate).left;
                    const i1 = bisectDate(data.period1, x1, 1);
                    const i2 = bisectDate(data.period2, x1, 1);
                    
                    const d1 = i1 > 0 ? data.period1[i1 - 1] : null;
                    const d2 = i2 > 0 ? data.period2[i2 - 1] : null;
                    
                    if (d1 || d2) {
                        const date = x1;
                        const bufferValue = d1 ? d1.value * 1.2 : null;
                        
                        tooltip.html(`
                            <div class="font-bold">${date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}</div>
                            ${d1 ? `<div style="color: ${COLORS.period1}">${TIME_PERIODS.period1.label}: ${d1.value.toLocaleString()}</div>` : ''}
                            ${d1 ? `<div style="color: ${COLORS.buffer}">Buffer (+20%): ${Math.round(bufferValue).toLocaleString()}</div>` : ''}
                            ${d2 ? `<div style="color: ${COLORS.period2}">${TIME_PERIODS.period2.label}: ${d2.value.toLocaleString()}</div>` : ''}
                        `)
                            .style('left', `${event.pageX + 10}px`)
                            .style('top', `${event.pageY - 10}px`);
                    }
                });
        }

        const DATA_CONFIG = {
            dataPath: 'goldsport__ga_classicskischool_daily_metrix___gsp_dataset___auto_full/method=auto_full/source=goldsport/goldsport__ga_classicskischool_daily_metrix.tsv'
        };

        async function loadData() {
            try {
                console.log('Attempting to load data from:', DATA_CONFIG.dataPath);
                
                const response = await fetch(DATA_CONFIG.dataPath);
                if (!response.ok) {
                    console.error(`Failed to load data from ${DATA_CONFIG.dataPath}`);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                
                const parsed = Papa.parse(text, {
                    header: true,
                    skipEmptyLines: true,
                    delimiter: '\t',
                    dynamicTyping: true
                });

                return parsed.data;
            } catch (error) {
                console.error('Error loading data:', error);
                return [];
            }
        }

        function processData(data, timeframe, pageType, selectedMetric) {
            const paths = Object.values(LANG_PATHS).map(p => p[pageType]);
            
            function processForPeriod(period) {
                const periodData = data.filter(row => {
                    const rowDate = new Date(row.date);
                    return rowDate >= period.start && 
                           rowDate <= period.end && 
                           paths.includes(row.code) &&
                           row.type === selectedMetric;
                });

                const groupData = timeframe === 'weekly' 
                    ? _.groupBy(periodData, row => {
                        const date = new Date(row.date);
                        const weekNum = Math.ceil((date - new Date(date.getFullYear(), 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                        return `${date.getFullYear()}-${weekNum}`;
                    })
                    : _.groupBy(periodData, 'date');

                let cumulative = 0;

                return _(groupData)
                    .map((rows, dateKey) => {
                        const totalValue = _.sumBy(rows, row => parseFloat(row.value) || 0);
                        if (selectedMetric !== 'Average engagement time per session') {
                            cumulative += totalValue;
                        }

                        const date = new Date(rows[0].date);
                        const normalizedDate = date >= TIME_PERIODS.period2.start 
                            ? normalizePeriod2Date(date)
                            : date;

                        return {
                            date,
                            normalizedDate,
                            value: selectedMetric !== 'Average engagement time per session' ? cumulative : totalValue
                        };
                    })
                    .sortBy('date')
                    .value();
            }

            return {
                period1: processForPeriod(TIME_PERIODS.period1),
                period2: processForPeriod(TIME_PERIODS.period2)
            };
        }

        async function updateDashboard(data) {
            if (!data || !data.length) {
                console.error('No data available for dashboard update');
                document.getElementById('mainTitle').textContent = 'Error loading data';
                return;
            }

            const timeframe = document.getElementById('timeSelector').value;
            const selectedMetric = document.getElementById('metricSelector').value;
            
            // Update title with selected metric and latest date
            const latestRow = _.maxBy(data, row => new Date(row.date));
            const latestDate = latestRow ? new Date(latestRow.date) : new Date();
            document.getElementById('mainTitle').textContent = 
                `${selectedMetric} All Languages | ${selectedMetric !== 'Average engagement time per session' ? 'Cumulative | ' : ''}Latest day processed: ${latestDate.toISOString().split('T')[0]}`;
            
            // Process and create charts for main pages
            const mainData = processData(data, timeframe, 'main', selectedMetric);
            createChart(mainData, 'chart-main', 'Main Pages');
            
            // Process and create charts for order pages
            const orderData = processData(data, timeframe, 'order', selectedMetric);
            createChart(orderData, 'chart-order', 'Order Pages');
        }

        async function initialize() {
            try {
                const data = await loadData();
                if (!data || !data.length) {
                    console.error('No data loaded');
                    document.getElementById('mainTitle').textContent = 'Error: No data available';
                    return;
                }

                const timeSelector = document.getElementById('timeSelector');
                const metricSelector = document.getElementById('metricSelector');
                
                timeSelector.addEventListener('change', () => updateDashboard(data));
                metricSelector.addEventListener('change', () => updateDashboard(data));
                
                await updateDashboard(data);
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
                document.getElementById('mainTitle').textContent = 'Error: Failed to load data';
            }
        }

        initialize();
        window.addEventListener('resize', _.debounce(() => {
            const data = loadData().then(data => updateDashboard(data));
        }, 250));
    </script>
</body>
</html>