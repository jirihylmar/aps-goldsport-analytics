<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Analytics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        .chart-tooltip {
            position: absolute;
            padding: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: none;
            font-size: 12px;
            opacity: 0;
            z-index: 100;
        }
        .chart-tooltip.visible { opacity: 1; }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto p-4">
        <div class="flex justify-between items-center mb-6">
            <div>
                <h1 class="text-2xl font-bold">Analytics by Language | <span id="selectedMetric">New Users</span> | Latest day processed: <span id="latestDate">Loading...</span></h1>
                <div class="mt-4">
                    <select id="metricSelector" class="p-2 border rounded">
                        <option value="New users">New Users</option>
                        <option value="Active users">Active Users</option>
                        <option value="Sessions">Sessions</option>
                        <option value="Average engagement time per session">Avg. Engagement Time</option>
                    </select>
                </div>
            </div>
            <select id="timeSelector" class="p-2 border rounded">
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
            </select>
        </div>
        <div id="chartsContainer" class="space-y-4"></div>
    </div>

    <script>
        const DATA_CONFIG = {
            historyPath: 'goldsport__ga_classicskischool_daily_metrix___gsp_dataset___auto_full/method=auto_full/source=goldsport/goldsport__ga_classicskischool_daily_metrix.tsv',
            currentPath: 'goldsport__ga_classicskischool_daily_metrix___gsp_dataset___hand_increment/method=hand_increment/source=goldsport/ga_classicskischool-current-season.tsv'
        };

        const LANG_PATHS = {
            en: {
                main: '/en',
                order: '/en/objednavka',
                label: 'English'
            },
            de: {
                main: '/de',
                order: '/de/objednavka',
                label: 'German'
            },
            pl: {
                main: '/pl',
                order: '/pl/objednavka',
                label: 'Polish'
            },
            cs: {
                main: '/',
                order: '/objednavka',
                label: 'Czech'
            }
        };

        const COLORS = {
            main: '#4f46e5',
            order: '#e11d48'
        };

        function createChart(data, lang, containerId) {
            const container = document.getElementById(containerId);
            d3.select(`#${containerId}`).selectAll('*').remove();

            const margin = {top: 20, right: 50, bottom: 30, left: 50};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleTime()
                .domain(d3.extent(data, d => d.date))
                .range([0, width]);

            const y1 = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.mainValue)])
                .nice()
                .range([height, 0]);

            const y2 = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.orderValue)])
                .nice()
                .range([height, 0]);

            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .tickFormat(d3.timeFormat('%Y %b'))
                    .ticks(d3.timeMonth.every(1)));

            svg.append('g')
                .call(d3.axisLeft(y1).tickFormat(d3.format('d')));

            svg.append('g')
                .attr('transform', `translate(${width},0)`)
                .call(d3.axisRight(y2).tickFormat(d3.format('d')))
                .selectAll('.tick text')
                .attr('dx', '0.5em');

            const mainLine = d3.line()
                .x(d => x(d.date))
                .y(d => y1(d.mainValue))
                .defined(d => !isNaN(d.mainValue));

            const orderLine = d3.line()
                .x(d => x(d.date))
                .y(d => y2(d.orderValue))
                .defined(d => !isNaN(d.orderValue));

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', COLORS.main)
                .attr('stroke-width', 2)
                .attr('d', mainLine);

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', COLORS.order)
                .attr('stroke-width', 2)
                .attr('d', orderLine);

            svg.selectAll('dot-main')
                .data(data)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.date))
                .attr('cy', d => y1(d.mainValue))
                .attr('r', 3)
                .attr('fill', COLORS.main)
                .attr('stroke', 'white')
                .attr('stroke-width', 1);

            svg.selectAll('dot-order')
                .data(data)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.date))
                .attr('cy', d => y2(d.orderValue))
                .attr('r', 3)
                .attr('fill', COLORS.order)
                .attr('stroke', 'white')
                .attr('stroke-width', 1);

            const legend = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width/2 - 100},${-10})`);

            const entries = [
                { name: 'Main Page', color: COLORS.main },
                { name: 'Order Page', color: COLORS.order }
            ];

            entries.forEach((entry, i) => {
                const legendRow = legend.append('g')
                    .attr('transform', `translate(${i * 120}, 0)`);

                legendRow.append('rect')
                    .attr('width', 10)
                    .attr('height', 10)
                    .attr('fill', entry.color);

                legendRow.append('text')
                    .attr('x', 20)
                    .attr('y', 10)
                    .text(entry.name);
            });

            const tooltip = d3.select(`#${containerId}`)
                .append('div')
                .attr('class', 'chart-tooltip');

            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', () => tooltip.classed('visible', true))
                .on('mouseout', () => tooltip.classed('visible', false))
                .on('mousemove', (event) => {
                    const [x0] = d3.pointer(event);
                    const bisectDate = d3.bisector(d => d.date).left;
                    const x1 = x.invert(x0);
                    const i = bisectDate(data, x1, 1);
                    if (i > 0) {
                        const d0 = data[i - 1];
                        const d1 = data[i] || d0;
                        const d = x1 - d0.date > d1.date - x1 ? d1 : d0;
                        const weekNum = getWeekNumber(d.date);

                        tooltip
                            .html(`
                                <div class="font-bold">Week ${weekNum}</div>
                                <div style="color: ${COLORS.main}">Main Page: ${d.mainValue}</div>
                                <div style="color: ${COLORS.order}">Order Page: ${d.orderValue}</div>
                            `)
                            .style('left', `${event.pageX + 10}px`)
                            .style('top', `${event.pageY - 10}px`);
                    }
                });
        }

        function getWeekNumber(d) {
            const date = new Date(d);
            date.setHours(0, 0, 0, 0);
            date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
            const week1 = new Date(date.getFullYear(), 0, 4);
            return 1 + Math.round(((date - week1) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
        }

        async function loadData() {
            try {
                // Load both history and current season data
                const [historyResponse, currentResponse] = await Promise.all([
                    fetch(DATA_CONFIG.historyPath),
                    fetch(DATA_CONFIG.currentPath)
                ]);

                let allData = [];

                if (historyResponse.ok) {
                    const historyText = await historyResponse.text();
                    const historyParsed = Papa.parse(historyText, {
                        header: true,
                        skipEmptyLines: true,
                        delimiter: '\t',
                        dynamicTyping: true
                    });
                    allData = allData.concat(historyParsed.data);
                }

                if (currentResponse.ok) {
                    const currentText = await currentResponse.text();
                    const currentParsed = Papa.parse(currentText, {
                        header: true,
                        skipEmptyLines: true,
                        delimiter: '\t',
                        dynamicTyping: true
                    });
                    allData = allData.concat(currentParsed.data);
                }

                // Remove duplicates by date+code+type, keeping latest
                const uniqueData = _.uniqBy(allData.reverse(), row => `${row.date}-${row.code}-${row.type}`).reverse();

                return uniqueData;
            } catch (error) {
                console.error('Error loading data:', error);
                return [];
            }
        }

        function processData(data, selectedLang, timeframe, selectedMetric) {
            const paths = LANG_PATHS[selectedLang];
            
            // Filter data for selected metric
            const metricData = data.filter(row => row.type === selectedMetric);

            const groupData = timeframe === 'weekly' 
                ? _.groupBy(metricData, row => {
                    const date = new Date(row.date);
                    const weekNum = Math.ceil((date - new Date(date.getFullYear(), 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                    return `${date.getFullYear()}-${weekNum}`;
                })
                : _.groupBy(metricData, 'date');

            return _(groupData)
                .map((rows, dateKey) => {
                    const mainRows = rows.filter(row => row.code === paths.main);
                    const orderRows = rows.filter(row => row.code === paths.order);

                    return {
                        date: new Date(rows[0].date),
                        mainValue: _.sumBy(mainRows, 'value') || 0,
                        orderValue: _.sumBy(orderRows, 'value') || 0
                    };
                })
                .sortBy('date')
                .value();
        }

        function createLanguageSection(lang) {
            const section = document.createElement('div');
            section.className = 'bg-white rounded-lg shadow p-4';
            
            const title = document.createElement('h2');
            title.className = 'text-lg font-bold mb-2';
            title.textContent = LANG_PATHS[lang].label;
            section.appendChild(title);
            
            const chartDiv = document.createElement('div');
            chartDiv.className = 'h-48';
            chartDiv.id = `chart-${lang}`;
            section.appendChild(chartDiv);
            
            return section;
        }

        async function updateDashboard(data) {
            if (!data || !data.length) {
                console.error('No data available for dashboard update');
                return;
            }

            const timeframe = document.getElementById('timeSelector').value;
            const selectedMetric = document.getElementById('metricSelector').value;
            const container = document.getElementById('chartsContainer');
            
            // Update header with selected metric and latest date
            document.getElementById('selectedMetric').textContent = selectedMetric;
            const latestDate = new Date(_.max(data.map(row => new Date(row.date))));
            document.getElementById('latestDate').textContent = latestDate.toISOString().split('T')[0];
            
            container.innerHTML = '';

            Object.keys(LANG_PATHS).forEach(lang => {
                const section = createLanguageSection(lang);
                container.appendChild(section);
                const processedData = processData(data, lang, timeframe, selectedMetric);
                createChart(processedData, lang, `chart-${lang}`);
            });
        }

        async function initialize() {
            try {
                const data = await loadData();
                if (!data || !data.length) {
                    console.error('No data loaded');
                    return;
                }

                const timeSelector = document.getElementById('timeSelector');
                const metricSelector = document.getElementById('metricSelector');
                
                timeSelector.addEventListener('change', () => updateDashboard(data));
                metricSelector.addEventListener('change', () => updateDashboard(data));
                
                await updateDashboard(data);
            } catch (error) {
                console.error('Failed to initialize dashboard:', error);
            }
        }

        initialize();
        window.addEventListener('resize', _.debounce(() => {
            loadData().then(data => updateDashboard(data));
        }, 250));
    </script>
</body>
</html>